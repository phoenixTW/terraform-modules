## Terraform Modules Monorepo

This repository contains versioned Terraform modules managed in a single monorepo.
Each module lives at the repository root (for example, `common_vpc/`) and is versioned
independently using the [`techpivot/terraform-module-releaser`](https://github.com/techpivot/terraform-module-releaser)
GitHub Action.

### Repository structure

```text
common-terraform-modules/
├── .github/
│   └── workflows/
│       ├── terraform-ci.yml               # CI checks (fmt, validate, tflint, trivy, tfsec)
│       └── terraform-module-releaser.yml  # Per-module versioning, tags, releases, wiki
├── .tflint.hcl                             # TFLint configuration (AWS ruleset)
├── .gitignore
├── README.md
└── common_vpc/                             # Example VPC module (independently versioned)
```

Additional modules should also be placed at the repository root, for example:

```text
common-terraform-modules/
├── common_vpc/
├── app_network/
└── shared_services_vpc/
```

### Using modules from this monorepo

Each module is tagged with its own version in the form:

```text
<module_name>/vMAJOR.MINOR.PATCH
```

For the `common_vpc` module, a tag would look like:

- `common_vpc/v1.2.0`

You can consume the module from another Terraform project like this:

```hcl
module "vpc" {
  source = "git::https://github.com/phoenixTW/common-terraform-modules.git//common_vpc?ref=common_vpc/v1.2.0"

  # Example inputs
  service_name       = "my-service"
  env                = "prod"
  cidr               = "10.0.0.0/16"
  public_subnets     = ["10.0.1.0/24", "10.0.2.0/24"]
  private_subnets    = ["10.0.11.0/24", "10.0.12.0/24"]
  database_subnets   = ["10.0.21.0/24", "10.0.22.0/24"]
  availability_zones = ["eu-west-1a", "eu-west-1b"]
  tags               = { Owner = "platform", Project = "networking" }
}
```

> The wiki pages generated by `terraform-module-releaser` will always show
> the correct source URL and `?ref=` values for each module and version.

### Conventional commits and versioning

This repository uses **Conventional Commits** to drive semantic versioning of each module.
The `terraform-module-releaser` workflow looks at commit messages affecting each module
and decides the next version according to configured keywords:

- **major**: any commit message containing `breaking change` or `BREAKING CHANGE`
- **minor**: commit messages starting with `feat:` or `feature:`
- **patch**: commit messages starting with `fix:`, `chore:`, `docs:`,
  `refactor:`, `style:`, `perf:`, `test:`, or `ci:`
- If no keywords are matched, the default bump is **patch**

Examples:

- `feat(common_vpc): add new private subnet` → minor bump for `common_vpc`
- `fix(common_vpc): correct NAT gateway route` → patch bump for `common_vpc`
- `feat(common_vpc)!: change CIDR input type` and/or body containing `BREAKING CHANGE` → major bump

Only modules with changed files (excluding files that match
`module-change-exclude-patterns`) will receive a new version.

### CI checks (quality gates)

On every pull request targeting `main`, the `Terraform CI` workflow:

1. Detects which modules have changed Terraform files.
2. Runs the following checks for each changed module in a matrix job:
   - `terraform fmt -check -recursive`
   - `terraform init -backend=false`
   - `terraform validate`
   - `tflint` (using `.tflint.hcl`)
   - `trivy` (IaC misconfiguration scan)
   - `tfsec` (Terraform security scan)

It is recommended to configure branch protection rules so that this CI workflow
must pass before pull requests can be merged into `main`.

### Release automation and wiki

The `Terraform Module Releaser` workflow:

- Runs on pull request events (`opened`, `reopened`, `synchronize`, `closed`) targeting `main`.
- On open/update, comments on the PR with planned releases per module.
- On merge (`closed` with merge), creates:
  - Module-specific tags (for example, `common_vpc/v1.2.0`)
  - GitHub Releases containing module archives
  - GitHub Wiki pages per module with:
    - Usage examples (including correct `source` and `ref` values)
    - `terraform-docs` generated inputs/outputs
    - Changelogs

Before using wiki-based docs, ensure that the repository wiki is enabled in GitHub
settings and that an initial wiki page (e.g., `Home`) has been created.

### Adding a new module

1. Create a new directory at the repo root, e.g. `my_new_module/`.
2. Add your Terraform files (`main.tf`, `vars.tf`, `outputs.tf`, etc.).
3. Open a pull request using conventional commit messages.
4. Ensure the `Terraform CI` workflow passes.
5. On merge, the `terraform-module-releaser` workflow will create the initial tag
   (default `v1.0.0`, i.e. `my_new_module/v1.0.0`) and wiki documentation.

